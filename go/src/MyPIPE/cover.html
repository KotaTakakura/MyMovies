
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>handler: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">MyPIPE/handler/Authorization.go (100.0%)</option>
				
				<option value="file1">MyPIPE/handler/ChangeOrderOfPlayListMovies.go (97.2%)</option>
				
				<option value="file2">MyPIPE/handler/ChangePassword.go (95.7%)</option>
				
				<option value="file3">MyPIPE/handler/ChangeUserName.go (95.7%)</option>
				
				<option value="file4">MyPIPE/handler/ChangeUserProfileImage.go (96.2%)</option>
				
				<option value="file5">MyPIPE/handler/CheckUserAlreadyLikedMovie.go (100.0%)</option>
				
				<option value="file6">MyPIPE/handler/DeletePlayList.go (95.8%)</option>
				
				<option value="file7">MyPIPE/handler/EvaluateMovie.go (96.6%)</option>
				
				<option value="file8">MyPIPE/handler/FollowUser.go (0.0%)</option>
				
				<option value="file9">MyPIPE/handler/GetLoggedInUserData.go (64.3%)</option>
				
				<option value="file10">MyPIPE/handler/GetMovieAndComments.go (85.7%)</option>
				
				<option value="file11">MyPIPE/handler/IndexMovie.go (66.7%)</option>
				
				<option value="file12">MyPIPE/handler/IndexPlayListInMovieListPage.go (82.6%)</option>
				
				<option value="file13">MyPIPE/handler/IndexPlayListMovies.go (82.6%)</option>
				
				<option value="file14">MyPIPE/handler/IndexPlayListsInMyPage.go (57.9%)</option>
				
				<option value="file15">MyPIPE/handler/Movie.go (88.9%)</option>
				
				<option value="file16">MyPIPE/handler/PlayList.go (93.3%)</option>
				
				<option value="file17">MyPIPE/handler/PlayListItem.go (96.2%)</option>
				
				<option value="file18">MyPIPE/handler/PostComment.go (93.1%)</option>
				
				<option value="file19">MyPIPE/handler/UploadMovieFile.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package handler

import (
        "MyPIPE/domain/model"
        "MyPIPE/domain/repository"
        "MyPIPE/usecase"
        "github.com/gin-gonic/gin"
        "net/http"
)

type Authorization struct {
        UserRepository                   repository.UserRepository
        UserTemporaryRegistrationUsecase usecase.IUserTemporaryRegistration
        UserRegisterUsecase              usecase.IUserRegister
}

func NewAuthorization(userRep repository.UserRepository, userTemporaryRegistrationUsecase usecase.IUserTemporaryRegistration, userRegisterUsecase usecase.IUserRegister) *Authorization <span class="cov8" title="1">{
        return &amp;Authorization{
                UserRepository:                   userRep,
                UserTemporaryRegistrationUsecase: userTemporaryRegistrationUsecase,
                UserRegisterUsecase:              userRegisterUsecase,
        }
}</span>

func (authorization Authorization) TemporaryRegisterUser(c *gin.Context) <span class="cov8" title="1">{

        var newUserInfo TemporaryRegisterUserJson
        var newUser model.User
        validationError := map[string]error{}
        validationErrorMessages := map[string]string{}

        c.Bind(&amp;newUserInfo)
        newUser.Email, validationError["user_email"] = model.NewUserEmail(newUserInfo.Email)

        if validationError["user_email"] != nil </span><span class="cov8" title="1">{
                validationErrorMessages["user_email"] = validationError["user_email"].Error()
                c.JSON(http.StatusBadRequest, gin.H{
                        "result":  "Validation Error",
                        "message": validationErrorMessages,
                })
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">err := authorization.UserTemporaryRegistrationUsecase.TemporaryRegister(&amp;newUser)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "message": "Temporary Registered!",
                })
                c.Abort()
                return
        }</span>
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "message": "Temporary Registered!",
        })</span>
}

type TemporaryRegisterUserJson struct {
        Email string `json:"user_email"`
}

func (authorization Authorization) RegisterUser(c *gin.Context) <span class="cov8" title="1">{

        var newUserInfo RegisterUserJson
        c.Bind(&amp;newUserInfo)

        validationErrors := map[string]error{}
        errorMessages := map[string]string{}
        validationErrorFlag := false

        token := c.Query("token")

        var newUser model.User
        newUser.Name, validationErrors["user_name"] = model.NewUserName(newUserInfo.Name)

        newUser.Password, validationErrors["user_password"] = model.NewUserPassword(newUserInfo.Password)

        newUser.Token, validationErrors["user_token"] = model.NewUserToken(token)

        validationErrors["user_birthday"] = newUser.SetBirthday(newUserInfo.Birthday)

        for errorKey, errorContent := range validationErrors </span><span class="cov8" title="1">{
                if errorContent != nil </span><span class="cov8" title="1">{
                        validationErrorFlag = true
                        errorMessages[errorKey] = errorContent.Error()
                }</span>
        }

        <span class="cov8" title="1">if validationErrorFlag </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "result":   "Validation Error",
                        "messages": errorMessages,
                })
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">registerUserError := authorization.UserRegisterUsecase.RegisterUser(&amp;newUser)

        if registerUserError != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "result":   "Registration Error",
                        "messages": registerUserError.Error(),
                })
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "message": "Registered!",
        })</span>
}

type RegisterUserJson struct {
        Name     string `json:"user_name"`
        Password string `json:"user_password"`
        Birthday string `json:"user_birthday"`
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package handler

import (
        "MyPIPE/domain/model"
        "MyPIPE/domain/repository"
        "MyPIPE/usecase"
        "encoding/json"
        jwt "github.com/appleboy/gin-jwt/v2"
        "github.com/gin-gonic/gin"
        "net/http"
)

type ChangeOrderOfPlayListMovies struct {
        PlayListMovieRepository            repository.PlayListMovieRepository
        ChangeOrderOfPlayListMoviesUsecase usecase.IChangeOrderOfPlayListMovies
}

func NewChangeOrderOfPlayListMovies(playListMovieRepo repository.PlayListMovieRepository, changeOrderOfPlayListMoviesUsecase usecase.IChangeOrderOfPlayListMovies) *ChangeOrderOfPlayListMovies <span class="cov8" title="1">{
        return &amp;ChangeOrderOfPlayListMovies{
                PlayListMovieRepository:            playListMovieRepo,
                ChangeOrderOfPlayListMoviesUsecase: changeOrderOfPlayListMoviesUsecase,
        }
}</span>

func (changeOrderOfPlayListMovies ChangeOrderOfPlayListMovies) ChangeOrderOfPlayListMovies(c *gin.Context) <span class="cov8" title="1">{
        var changeOrderOfPlayListMoviesJson ChangeOrderOfPlayListMoviesJson
        c.Bind(&amp;changeOrderOfPlayListMoviesJson)
        userIdUint := uint64(jwt.ExtractClaims(c)["id"].(float64))

        validationErrors := make(map[string]string)
        var movieIdAndOrderForChangeOrderOfPlayListMoviesDTO usecase.MovieIdAndOrderForChangeOrderOfPlayListMoviesDTO
        var changeOrderOfPlayListMoviesDTO usecase.ChangeOrderOfPlayListMoviesDTO
        for _, value := range changeOrderOfPlayListMoviesJson.PlayListMovieIdAndOrder </span><span class="cov8" title="1">{
                var movieIdErr error
                movieIdAndOrderForChangeOrderOfPlayListMoviesDTO.MovieID, movieIdErr = model.NewMovieID(value.MovieID)
                if movieIdErr != nil </span><span class="cov8" title="1">{
                        validationErrors["movie_id"] = movieIdErr.Error()
                }</span>

                <span class="cov8" title="1">var OrderErr error
                movieIdAndOrderForChangeOrderOfPlayListMoviesDTO.Order, OrderErr = model.NewPlayListMovieOrder(value.Order)
                if OrderErr != nil </span><span class="cov8" title="1">{
                        validationErrors["order"] = OrderErr.Error()
                }</span>

                <span class="cov8" title="1">changeOrderOfPlayListMoviesDTO.MovieIDAndOrder = append(changeOrderOfPlayListMoviesDTO.MovieIDAndOrder, movieIdAndOrderForChangeOrderOfPlayListMoviesDTO)</span>
        }

        <span class="cov8" title="1">userId, userIdErr := model.NewUserID(userIdUint)
        if userIdErr != nil </span><span class="cov0" title="0">{
                validationErrors["user_id"] = userIdErr.Error()
        }</span>

        <span class="cov8" title="1">playListID, playListIDErr := model.NewPlayListID(changeOrderOfPlayListMoviesJson.PlayListID)
        if playListIDErr != nil </span><span class="cov8" title="1">{
                validationErrors["play_list_id"] = playListIDErr.Error()
        }</span>

        <span class="cov8" title="1">if len(validationErrors) != 0 </span><span class="cov8" title="1">{
                validationErrors, _ := json.Marshal(validationErrors)
                c.JSON(http.StatusBadRequest, gin.H{
                        "result":   "Validation Error.",
                        "messages": string(validationErrors),
                })
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">changeOrderOfPlayListMoviesDTO.UserID = userId
        changeOrderOfPlayListMoviesDTO.PlayListID = playListID

        result := changeOrderOfPlayListMovies.ChangeOrderOfPlayListMoviesUsecase.ChangeOrderOfPlayListMovies(&amp;changeOrderOfPlayListMoviesDTO)
        if result != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "result":   "Validation Error.",
                        "messages": result.Error(),
                })
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "message": "OK",
        })</span>
}

type ChangeOrderOfPlayListMoviesJson struct {
        PlayListID              uint64                                                      `json:"play_list_id"`
        PlayListMovieIdAndOrder []PlayListMovieIdAndOrderForChangeOrderOfPlayListMoviesJson `json:"play_list_movie_id_and_order"`
}

type PlayListMovieIdAndOrderForChangeOrderOfPlayListMoviesJson struct {
        MovieID uint64 `json:"play_list_movie_id"`
        Order   int    `json:"play_lise_movie_order"`
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package handler

import (
        "MyPIPE/domain/model"
        "MyPIPE/domain/repository"
        "MyPIPE/usecase"
        "encoding/json"
        jwt "github.com/appleboy/gin-jwt/v2"
        "github.com/gin-gonic/gin"
        "net/http"
)

type ChangePassword struct {
        UsrRepository         repository.UserRepository
        ChangePasswordUsecase usecase.IChangePassword
}

func NewChangePassword(u repository.UserRepository, c usecase.IChangePassword) *ChangePassword <span class="cov8" title="1">{
        return &amp;ChangePassword{
                UsrRepository:         u,
                ChangePasswordUsecase: c,
        }
}</span>

func (changePassword ChangePassword) ChangePassword(c *gin.Context) <span class="cov8" title="1">{
        userIdUint := uint64(jwt.ExtractClaims(c)["id"].(float64))
        validationErrors := make(map[string]string)
        userId, userIdErr := model.NewUserID(userIdUint)
        if userIdErr != nil </span><span class="cov0" title="0">{
                validationErrors["user_id"] = userIdErr.Error()
        }</span>

        <span class="cov8" title="1">var changePasswordJson ChangePasswordJson
        c.Bind(&amp;changePasswordJson)
        userPassword, userPasswordErr := model.NewUserPassword(changePasswordJson.Password)
        if userPasswordErr != nil </span><span class="cov8" title="1">{
                validationErrors["password"] = userPasswordErr.Error()
        }</span>

        <span class="cov8" title="1">if len(validationErrors) != 0 </span><span class="cov8" title="1">{
                validationErrors, _ := json.Marshal(validationErrors)
                c.JSON(http.StatusBadRequest, gin.H{
                        "result":   "Validation Error.",
                        "messages": string(validationErrors),
                })
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">changePasswordDTO := usecase.NewChangePasswordDTO(userId, userPassword)
        err := changePassword.ChangePasswordUsecase.ChangePassword(changePasswordDTO)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "result":   "Error.",
                        "messages": err.Error(),
                })
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "result":   "Success.",
                "messages": "OK",
        })</span>

}

type ChangePasswordJson struct {
        Password string `json:"password"`
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package handler

import (
        "MyPIPE/domain/model"
        "MyPIPE/domain/repository"
        "MyPIPE/usecase"
        "encoding/json"
        jwt "github.com/appleboy/gin-jwt/v2"
        "github.com/gin-gonic/gin"
        "net/http"
)

type ChangeUserName struct {
        UserRepository        repository.UserRepository
        ChangeUserNameUsecase usecase.IChangeUserName
}

func NewChangeUserName(u repository.UserRepository, c usecase.IChangeUserName) *ChangeUserName <span class="cov8" title="1">{
        return &amp;ChangeUserName{
                UserRepository:        u,
                ChangeUserNameUsecase: c,
        }
}</span>

func (changeUserName ChangeUserName) ChangeUserName(c *gin.Context) <span class="cov8" title="1">{
        userIdUint := uint64(jwt.ExtractClaims(c)["id"].(float64))
        validationErrors := make(map[string]string)

        userId, userIdErr := model.NewUserID(userIdUint)
        if userIdErr != nil </span><span class="cov0" title="0">{
                validationErrors["user_id"] = userIdErr.Error()
        }</span>

        <span class="cov8" title="1">var changeUserNameJson ChangeUserNameJson
        c.Bind(&amp;changeUserNameJson)
        userName, userNameErr := model.NewUserName(changeUserNameJson.UserName)
        if userNameErr != nil </span><span class="cov8" title="1">{
                validationErrors["user_name"] = userNameErr.Error()
        }</span>

        <span class="cov8" title="1">if len(validationErrors) != 0 </span><span class="cov8" title="1">{
                validationErrors, _ := json.Marshal(validationErrors)
                c.JSON(http.StatusBadRequest, gin.H{
                        "result":   "Validation Error.",
                        "messages": string(validationErrors),
                })
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">changeUserNameDTO := usecase.NewChangeUserNameDTO(userId, userName)
        err := changeUserName.ChangeUserNameUsecase.ChangeUserName(changeUserNameDTO)

        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "result":   "Error.",
                        "messages": err.Error(),
                })
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "result":   "Success.",
                "messages": "OK",
        })</span>

}

type ChangeUserNameJson struct {
        UserName string `json:"user_name"`
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package handler

import (
        "MyPIPE/domain/model"
        "MyPIPE/domain/repository"
        "MyPIPE/usecase"
        "encoding/json"
        jwt "github.com/appleboy/gin-jwt/v2"
        "github.com/gin-gonic/gin"
        "net/http"
)

type ChangeUserProfileImage struct {
        UserRepository                repository.UserRepository
        UserProfileImageRepository    repository.UserProfileImageRepository
        ChangeUserProfileImageUsecase usecase.IChangeUserProfilieImage
}

func NewChangeUserProfileImage(userRepo repository.UserRepository, userProfileImageRepo repository.UserProfileImageRepository, changeUserProfileImageUsecase usecase.IChangeUserProfilieImage) *ChangeUserProfileImage <span class="cov8" title="1">{
        return &amp;ChangeUserProfileImage{
                UserRepository:                userRepo,
                UserProfileImageRepository:    userProfileImageRepo,
                ChangeUserProfileImageUsecase: changeUserProfileImageUsecase,
        }
}</span>

func (changeUserProfileImage ChangeUserProfileImage) ChangeUserProfileImage(c *gin.Context) <span class="cov8" title="1">{
        userIdUint := uint64(jwt.ExtractClaims(c)["id"].(float64))
        validationErrors := make(map[string]string)

        userId, userIdErr := model.NewUserID(userIdUint)
        if userIdErr != nil </span><span class="cov0" title="0">{
                validationErrors["user_id"] = userIdErr.Error()
        }</span>

        <span class="cov8" title="1">var profileImage *model.UserProfileImage
        var profileImageErr error
        imageFile, imageHeader, imageFileErr := c.Request.FormFile("profileImage")
        if imageFileErr != nil </span><span class="cov8" title="1">{
                validationErrors["profile_image"] = imageFileErr.Error()
        }</span>else<span class="cov8" title="1">{
                profileImage,profileImageErr = model.NewUserProfileImage(*imageHeader,imageFile)
                if profileImageErr != nil</span><span class="cov8" title="1">{
                        validationErrors["profile_image"] = profileImageErr.Error()
                }</span>
        }

        <span class="cov8" title="1">if len(validationErrors) != 0 </span><span class="cov8" title="1">{
                validationErrors, _ := json.Marshal(validationErrors)
                c.JSON(http.StatusBadRequest, gin.H{
                        "result":   "Validation Error.",
                        "messages": string(validationErrors),
                })
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">changeUserProfileImageDTO := usecase.NewChangeUserProfileImageDTO(userId, profileImage)
        changeProfileImageErr := changeUserProfileImage.ChangeUserProfileImageUsecase.ChangeUserProfileImage(changeUserProfileImageDTO)
        if changeProfileImageErr != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "result":   "Profile Image Set Failed.",
                        "messages": changeProfileImageErr.Error(),
                })
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "message": "Posted!",
        })</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package handler

import (
        "MyPIPE/domain/model"
        "MyPIPE/domain/repository"
        "MyPIPE/usecase"
        "encoding/json"
        "github.com/gin-gonic/gin"
        "net/http"
        "strconv"
)

type CheckUserAlreadyLikedMovie struct {
        MovieEvaluationRepository         repository.MovieEvaluationRepository
        CheckUserAlreadyLikedMovieUsecase usecase.ICheckUserAlreadyLikedMovie
}

func NewCheckUserAlreadyLikedMovie(movieEvaluationRepo repository.MovieEvaluationRepository, checkUserAlreadyLikedMovieUsecase usecase.ICheckUserAlreadyLikedMovie) *CheckUserAlreadyLikedMovie <span class="cov8" title="1">{
        return &amp;CheckUserAlreadyLikedMovie{
                MovieEvaluationRepository:         movieEvaluationRepo,
                CheckUserAlreadyLikedMovieUsecase: checkUserAlreadyLikedMovieUsecase,
        }
}</span>

func (checkUserAlreadyLikedMovie CheckUserAlreadyLikedMovie) CheckUserAlreadyLikedMovie(c *gin.Context) <span class="cov8" title="1">{
        var checkUserAlreadyLikedMovieJson CheckUserAlreadyLikedMovieJson
        c.Bind(&amp;checkUserAlreadyLikedMovieJson)
        userIdString := c.Query("user_id")
        movieIdString := c.Query("movie_id")

        validationErrors := make(map[string]string)
        var userId model.UserID
        var movieId model.MovieID

        userIdUint64, userIdUint64Err := strconv.ParseUint(userIdString, 10, 64)

        if userIdUint64Err != nil </span><span class="cov8" title="1">{
                validationErrors["user_id"] = userIdUint64Err.Error()
        }</span> else<span class="cov8" title="1"> {
                userId, _ = model.NewUserID(userIdUint64)
        }</span>

        <span class="cov8" title="1">movieIdUint64, movieIdUint64Err := strconv.ParseUint(movieIdString, 10, 64)
        if movieIdUint64Err != nil </span><span class="cov8" title="1">{
                validationErrors["movie_id"] = movieIdUint64Err.Error()
        }</span> else<span class="cov8" title="1"> {
                movieId, _ = model.NewMovieID(movieIdUint64)
        }</span>

        <span class="cov8" title="1">if len(validationErrors) != 0 </span><span class="cov8" title="1">{
                validationErrors, _ := json.Marshal(validationErrors)
                c.JSON(http.StatusBadRequest, gin.H{
                        "result":   "Validation Error.",
                        "messages": string(validationErrors),
                })
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">checkUserAlreadyLikedMovieFindDTO := usecase.NewCheckUserAlreadyLikedMovieFindDTO(userId, movieId)
        result := checkUserAlreadyLikedMovie.CheckUserAlreadyLikedMovieUsecase.Find(checkUserAlreadyLikedMovieFindDTO)

        if result </span><span class="cov8" title="1">{
                c.JSON(http.StatusOK, gin.H{
                        "evaluated": "true",
                })
        }</span> else<span class="cov8" title="1"> {
                c.JSON(http.StatusOK, gin.H{
                        "evaluated": "false",
                })
        }</span>
}

type CheckUserAlreadyLikedMovieJson struct {
        UserID  uint64
        MovieID uint64
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package handler

import (
        "MyPIPE/domain/model"
        "MyPIPE/domain/repository"
        "MyPIPE/usecase"
        "encoding/json"
        jwt "github.com/appleboy/gin-jwt/v2"
        "github.com/gin-gonic/gin"
        "net/http"
        "strconv"
)

type DeletePlayList struct {
        PlayListRepository    repository.PlayListRepository
        DeletePlayListUsecase usecase.IDeletePlayList
}

func NewDeletePlayList(playListRepo repository.PlayListRepository, deletePlayListUsecase usecase.IDeletePlayList) *DeletePlayList <span class="cov8" title="1">{
        return &amp;DeletePlayList{
                PlayListRepository:    playListRepo,
                DeletePlayListUsecase: deletePlayListUsecase,
        }
}</span>

func (deletePlayList DeletePlayList) DeletePlayList(c *gin.Context) <span class="cov8" title="1">{
        validationErrors := make(map[string]string)
        userIdUint := uint64((jwt.ExtractClaims(c)["id"]).(float64))
        userId, userIdErr := model.NewUserID(userIdUint)
        if userIdErr != nil </span><span class="cov0" title="0">{
                validationErrors["user_id"] = userIdErr.Error()
        }</span>

        <span class="cov8" title="1">var playListId model.PlayListID
        playListIdString := c.Query("play_list_id")
        playListIdUint, playListIdUintErr := strconv.ParseUint(playListIdString, 10, 64)
        if playListIdUintErr != nil </span><span class="cov8" title="1">{
                validationErrors["play_list_id"] = playListIdUintErr.Error()
        }</span> else<span class="cov8" title="1"> {
                playListId, _ = model.NewPlayListID(playListIdUint)
        }</span>

        <span class="cov8" title="1">if len(validationErrors) != 0 </span><span class="cov8" title="1">{
                validationErrors, _ := json.Marshal(validationErrors)
                c.JSON(http.StatusBadRequest, gin.H{
                        "result":   "Validation Error.",
                        "messages": string(validationErrors),
                })
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">deletePlayListDTO := usecase.NewDeletePlayListDTO(userId, playListId)
        result := deletePlayList.DeletePlayListUsecase.Delete(deletePlayListDTO)

        if result != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "result":   "Error.",
                        "messages": result.Error(),
                })
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "result":   "Success.",
                "messages": "OK",
        })</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package handler

import (
        "MyPIPE/domain/model"
        "MyPIPE/domain/repository"
        "MyPIPE/usecase"
        "encoding/json"
        jwt "github.com/appleboy/gin-jwt/v2"
        "github.com/gin-gonic/gin"
        "net/http"
)

type EvaluateMovie struct {
        MovieRepository           repository.MovieRepository
        MovieEvaluationRepository repository.MovieEvaluationRepository
        EvaluateMovieUsecase      usecase.IEvaluateMovie
}

func NewEvaluateMovie(movieRepo repository.MovieRepository, movieEvaluateRepo repository.MovieEvaluationRepository, evaluateMovieUsecase usecase.IEvaluateMovie) *EvaluateMovie <span class="cov8" title="1">{
        return &amp;EvaluateMovie{
                MovieRepository:           movieRepo,
                MovieEvaluationRepository: movieEvaluateRepo,
                EvaluateMovieUsecase:      evaluateMovieUsecase,
        }
}</span>

func (evaluateMovie EvaluateMovie) EvaluateMovie(c *gin.Context) <span class="cov8" title="1">{
        var evaluateMovieJson EvaluateMovieJson
        c.Bind(&amp;evaluateMovieJson)

        userId := uint64(jwt.ExtractClaims(c)["id"].(float64))
        var evaluateMovieDTO usecase.EvaluateMovieDTO
        validationErrors := make(map[string]string)
        var userIdErr error
        evaluateMovieDTO.UserID, userIdErr = model.NewUserID(userId)
        if userIdErr != nil </span><span class="cov0" title="0">{
                validationErrors["user_id"] = userIdErr.Error()
        }</span>

        <span class="cov8" title="1">var movieIdErr error
        evaluateMovieDTO.MovieID, movieIdErr = model.NewMovieID(evaluateMovieJson.MovieID)
        if movieIdErr != nil </span><span class="cov8" title="1">{
                validationErrors["movie_id"] = movieIdErr.Error()
        }</span>

        <span class="cov8" title="1">var evaluationErr error
        evaluateMovieDTO.Evaluation, evaluationErr = model.NewEvaluation(evaluateMovieJson.Evaluation)
        if evaluationErr != nil </span><span class="cov8" title="1">{
                validationErrors["evaluation"] = evaluationErr.Error()
        }</span>

        <span class="cov8" title="1">if len(validationErrors) != 0 </span><span class="cov8" title="1">{
                validationErrors, _ := json.Marshal(validationErrors)
                c.JSON(http.StatusBadRequest, gin.H{
                        "result":   "Validation Error.",
                        "messages": string(validationErrors),
                })
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">evaluateMovieUsecaseErr := evaluateMovie.EvaluateMovieUsecase.EvaluateMovie(&amp;evaluateMovieDTO)
        if evaluateMovieUsecaseErr != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "result":   "Error.",
                        "messages": evaluateMovieUsecaseErr.Error(),
                })
                c.Abort()
                return
        }</span>
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "result":   "Success.",
                "messages": "OK",
        })</span>
}

type EvaluateMovieJson struct {
        MovieID    uint64 `json:"movie_id"`
        Evaluation string `json:"evaluate"`
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package handler

import (
        "MyPIPE/domain/model"
        "MyPIPE/infra"
        "MyPIPE/usecase"
        "encoding/json"
        jwt "github.com/appleboy/gin-jwt/v2"
        "github.com/gin-gonic/gin"
        "net/http"
)

func FollowUser(c *gin.Context) <span class="cov0" title="0">{
        var followUserJson FollowUserJson
        c.Bind(&amp;followUserJson)
        userIdJWT := uint64(jwt.ExtractClaims(c)["id"].(float64))
        followUserJson.UserID = userIdJWT

        validationErrors := make(map[string]string)
        userId, userIdErr := model.NewUserID(followUserJson.UserID)
        if userIdErr != nil </span><span class="cov0" title="0">{
                validationErrors["user_id"] = userIdErr.Error()
        }</span>

        <span class="cov0" title="0">followId, followIdErr := model.NewUserID(followUserJson.FollowID)
        if followIdErr != nil </span><span class="cov0" title="0">{
                validationErrors["follow_id"] = followIdErr.Error()
        }</span>

        <span class="cov0" title="0">if len(validationErrors) != 0 </span><span class="cov0" title="0">{
                validationErrors, _ := json.Marshal(validationErrors)
                c.JSON(http.StatusBadRequest, gin.H{
                        "result":   "Validation Error.",
                        "messages": string(validationErrors),
                })
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">followUserDTO := usecase.NewFollowDTO(userId, followId)
        userRepository := infra.NewUserPersistence()
        followUserRepository := infra.NewFollowUserPersistence()
        followUserUsecase := usecase.NewFollowUser(userRepository, followUserRepository)
        followUserUsecaseErr := followUserUsecase.Follow(followUserDTO)
        if followUserUsecaseErr != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "result":   "Error.",
                        "messages": followUserUsecaseErr.Error(),
                })
                c.Abort()
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "result":   "Success.",
                "messages": "OK",
        })</span>
}

type FollowUserJson struct {
        UserID   uint64
        FollowID uint64 `json:"follow_id"`
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package handler

import (
        "MyPIPE/domain/model"
        "MyPIPE/domain/queryService"
        "MyPIPE/usecase"
        "encoding/json"
        jwt "github.com/appleboy/gin-jwt/v2"
        "github.com/gin-gonic/gin"
        "net/http"
)

type GetLoggedInUserData struct {
        GetLoggedInUserDataQueryService queryService.GetLoggedInUserDataQueryService
        GetLoggedInUserDataUsecase      usecase.IGetLoggedInUserData
}

func NewGetLoggedInUserData(GetLoggedInUserDataQueryService queryService.GetLoggedInUserDataQueryService, getLoggedInUserDataUsecase usecase.IGetLoggedInUserData) *GetLoggedInUserData <span class="cov8" title="1">{
        return &amp;GetLoggedInUserData{
                GetLoggedInUserDataQueryService: GetLoggedInUserDataQueryService,
                GetLoggedInUserDataUsecase:      getLoggedInUserDataUsecase,
        }
}</span>

func (getLoggedInUserData GetLoggedInUserData) GetLoggedInUserData(c *gin.Context) <span class="cov8" title="1">{
        validationErrors := make(map[string]string)
        userIdUint := uint64((jwt.ExtractClaims(c)["id"]).(float64))
        userId, userIdErr := model.NewUserID(userIdUint)
        if userIdErr != nil </span><span class="cov0" title="0">{
                validationErrors["user_id"] = userIdErr.Error()
        }</span>

        <span class="cov8" title="1">if len(validationErrors) != 0 </span><span class="cov0" title="0">{
                validationErrors, _ := json.Marshal(validationErrors)
                c.JSON(http.StatusBadRequest, gin.H{
                        "result":   "Validation Error.",
                        "messages": string(validationErrors),
                })
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">getLoggedInUserDataDTO := usecase.NewGetLoggedInUserDataDTO(userId)
        loggedInUser := getLoggedInUserData.GetLoggedInUserDataUsecase.Find(getLoggedInUserDataDTO)

        c.JSON(http.StatusOK, loggedInUser)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package handler

import (
        "MyPIPE/domain/model"
        "MyPIPE/domain/queryService"
        "MyPIPE/usecase"
        "encoding/json"
        "github.com/gin-gonic/gin"
        "net/http"
        "strconv"
)

type GetMovieAndComments struct {
        CommentQueryService queryService.CommentQueryService
        GetCommentsUsecase  usecase.IGetMovieAndComments
}

func NewGetMovieAndComments(commentQueryService queryService.CommentQueryService, getCommentsUsecase usecase.IGetMovieAndComments) *GetMovieAndComments <span class="cov8" title="1">{
        return &amp;GetMovieAndComments{
                CommentQueryService: commentQueryService,
                GetCommentsUsecase:  getCommentsUsecase,
        }
}</span>

func (getMovieAndComments GetMovieAndComments) GetMovieAndComments(c *gin.Context) <span class="cov8" title="1">{
        var getCommentsJson GetCommentsJson
        c.Bind(&amp;getCommentsJson)

        validationErrors := make(map[string]string)
        movieIdInt, _ := strconv.ParseUint(c.Query("movie_id"), 10, 64)
        movieId, movieIdErr := model.NewMovieID(movieIdInt)
        if movieIdErr != nil </span><span class="cov8" title="1">{
                validationErrors["movie_id"] = movieIdErr.Error()
        }</span>

        <span class="cov8" title="1">if len(validationErrors) != 0 </span><span class="cov8" title="1">{
                validationErrors, _ := json.Marshal(validationErrors)
                c.JSON(http.StatusBadRequest, gin.H{
                        "result":   "Validation Error.",
                        "messages": string(validationErrors),
                })
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">getCommentsDTO := usecase.NewGetMovieAndCommentsDTO(movieId)
        comments := getMovieAndComments.GetCommentsUsecase.Get(getCommentsDTO)

        jsonResult, jsonMarshalErr := json.Marshal(comments)
        if jsonMarshalErr != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "result":   "Validation Error.",
                        "messages": jsonMarshalErr.Error(),
                })
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, string(jsonResult))</span>
}

type GetCommentsJson struct {
        MovieID uint64
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package handler

import (
        "MyPIPE/domain/queryService"
        "MyPIPE/usecase"
        "encoding/json"
        "github.com/gin-gonic/gin"
        "net/http"
        "strconv"
)

type IndexMovie struct {
        IndexMovieQueryService queryService.IndexMovieQueryService
        IndexMovieUsecase      usecase.IIndexMovie
}

func NewIndexMovie(indexMovieQueryService queryService.IndexMovieQueryService, indexMovieUsecase usecase.IIndexMovie) *IndexMovie <span class="cov8" title="1">{
        return &amp;IndexMovie{
                IndexMovieQueryService: indexMovieQueryService,
                IndexMovieUsecase:      indexMovieUsecase,
        }
}</span>

func (indexMovie IndexMovie) IndexMovie(c *gin.Context) <span class="cov8" title="1">{
        keyWord := c.Query("keyWord")

        validationErrors := make(map[string]string)

        var page queryService.IndexMovieQueryServicePage
        pageInt, err := strconv.ParseUint(c.Query("page"), 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                page, _ = queryService.NewIndexMovieQueryServicePage(1)
        }</span> else<span class="cov8" title="1"> {
                page, _ = queryService.NewIndexMovieQueryServicePage(uint(pageInt))
        }</span>

        <span class="cov8" title="1">order, orderErr := queryService.NewIndexMovieQueryServiceOrder(c.Query("order"))
        if orderErr != nil </span><span class="cov0" title="0">{
                validationErrors["order"] = orderErr.Error()
        }</span>

        <span class="cov8" title="1">if len(validationErrors) != 0 </span><span class="cov0" title="0">{
                validationErrors, _ := json.Marshal(validationErrors)
                c.JSON(http.StatusBadRequest, gin.H{
                        "result":   "Validation Error.",
                        "messages": string(validationErrors),
                })
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">indexMovieSearchDTO := usecase.NewIndexMovieSearchDTO(page, keyWord, order)
        movies := indexMovie.IndexMovieUsecase.Search(indexMovieSearchDTO)

        jsonResult, jsonMarshalErr := json.Marshal(movies)
        if jsonMarshalErr != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "result":   "Server Error.",
                        "messages": jsonMarshalErr.Error(),
                })
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, string(jsonResult))</span>
}

type IndexMovieJson struct {
        KeyWord string
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package handler

import (
        "MyPIPE/domain/model"
        "MyPIPE/domain/queryService"
        "MyPIPE/usecase"
        "encoding/json"
        jwt "github.com/appleboy/gin-jwt/v2"
        "github.com/gin-gonic/gin"
        "net/http"
        "strconv"
)

type IndexPlayListInMovieListPage struct {
        IndexPlayListInMovieListPageQueryService queryService.IndexPlayListInMovieListPageQueryService
        IndexPlayListInMovieListPageUsecase      usecase.IIndexPlayListInMovieListPage
}

func NewIndexPlayListInMovieListPage(indexPlayListInMovieListPageQueryService queryService.IndexPlayListInMovieListPageQueryService, indexPlayListInMovieListPageUsecase usecase.IIndexPlayListInMovieListPage) *IndexPlayListInMovieListPage <span class="cov8" title="1">{
        return &amp;IndexPlayListInMovieListPage{
                IndexPlayListInMovieListPageQueryService: indexPlayListInMovieListPageQueryService,
                IndexPlayListInMovieListPageUsecase:      indexPlayListInMovieListPageUsecase,
        }
}</span>

func (indexPlayListInMovieListPage IndexPlayListInMovieListPage) IndexPlayListInMovieListPage(c *gin.Context) <span class="cov8" title="1">{
        userId, userIdErr := model.NewUserID(uint64(jwt.ExtractClaims(c)["id"].(float64)))

        validationErrors := make(map[string]string)

        if userIdErr != nil </span><span class="cov0" title="0">{
                validationErrors["user_id"] = userIdErr.Error()
        }</span>

        <span class="cov8" title="1">var movieId model.MovieID
        movieIdUint64, movieIdUint64Err := strconv.ParseUint(c.Param("movie_id"), 10, 64)
        if movieIdUint64Err != nil </span><span class="cov8" title="1">{
                validationErrors["movie_id"] = movieIdUint64Err.Error()
        }</span> else<span class="cov8" title="1"> {
                movieId, _ = model.NewMovieID(movieIdUint64)
        }</span>

        <span class="cov8" title="1">if len(validationErrors) != 0 </span><span class="cov8" title="1">{
                validationErrors, _ := json.Marshal(validationErrors)
                c.JSON(http.StatusBadRequest, gin.H{
                        "result":   "Validation Error.",
                        "messages": string(validationErrors),
                })
                c.Abort()
                return
        }</span>
        <span class="cov8" title="1">findDTO := usecase.NewFindDTO(userId, movieId)
        result := indexPlayListInMovieListPage.IndexPlayListInMovieListPageUsecase.Find(findDTO)

        jsonResult, jsonMarshalErr := json.Marshal(result)
        if jsonMarshalErr != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "result":   "Server Error.",
                        "messages": jsonMarshalErr.Error(),
                })
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, string(jsonResult))</span>

}
</pre>
		
		<pre class="file" id="file13" style="display: none">package handler

import (
        "MyPIPE/domain/model"
        "MyPIPE/domain/queryService"
        "MyPIPE/usecase"
        "encoding/json"
        jwt "github.com/appleboy/gin-jwt/v2"
        "github.com/gin-gonic/gin"
        "net/http"
        "strconv"
)

type IndexPlaylistMovies struct {
        IndexPlaylistMoviesQueryService queryService.IndexPlayListMovieQueryService
        IndexPlaylistMoviesUsecase      usecase.IIndexPlaylistItemInMyPage
}

func NewIndexPlaylistMovies(indexPlaylistMoviesQueryService queryService.IndexPlayListMovieQueryService, indexPlaylistMoviesUsecase usecase.IIndexPlaylistItemInMyPage) *IndexPlaylistMovies <span class="cov8" title="1">{
        return &amp;IndexPlaylistMovies{
                IndexPlaylistMoviesQueryService: indexPlaylistMoviesQueryService,
                IndexPlaylistMoviesUsecase:      indexPlaylistMoviesUsecase,
        }
}</span>

func (indexPlaylistMovies IndexPlaylistMovies) IndexPlaylistMovies(c *gin.Context) <span class="cov8" title="1">{
        userIdInt := uint64(jwt.ExtractClaims(c)["id"].(float64))
        playListIdInt, _ := strconv.ParseUint(c.Param("play_list_id"), 10, 64)

        validationErrors := make(map[string]string)

        userId, userIdErr := model.NewUserID(userIdInt)
        if userIdErr != nil </span><span class="cov0" title="0">{
                validationErrors["user_id"] = userIdErr.Error()
        }</span>

        <span class="cov8" title="1">playListId, playListIdErr := model.NewPlayListID(playListIdInt)
        if playListIdErr != nil </span><span class="cov8" title="1">{
                validationErrors["play_list_id"] = playListIdErr.Error()
        }</span>

        <span class="cov8" title="1">if len(validationErrors) != 0 </span><span class="cov8" title="1">{
                validationErrors, _ := json.Marshal(validationErrors)
                c.JSON(http.StatusBadRequest, gin.H{
                        "result":   "Validation Error.",
                        "messages": string(validationErrors),
                })
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">indexPlayListItemUsecaseDTO := usecase.NewIndexPlayListItemInMyPageDTO(userId, playListId)
        result := indexPlaylistMovies.IndexPlaylistMoviesUsecase.Find(indexPlayListItemUsecaseDTO)

        jsonResult, jsonMarshalErr := json.Marshal(result)
        if jsonMarshalErr != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "result":   "Server Error.",
                        "messages": jsonMarshalErr.Error(),
                })
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, string(jsonResult))</span>
}

type IndexPlayListMoviesJson struct {
        PlayListID uint64
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package handler

import (
        "MyPIPE/domain/model"
        "MyPIPE/domain/queryService"
        "MyPIPE/usecase"
        "encoding/json"
        jwt "github.com/appleboy/gin-jwt/v2"
        "github.com/gin-gonic/gin"
        "net/http"
)

type IndexPlayListsInMyPage struct {
        IndexPlayListsInMyPageQueryService queryService.IndexPlayListsInMyPageQueryService
        IndexPlayListsInMyPageUsecase      usecase.IIndexPlayListsInMyPage
}

func NewIndexPlayListsInMyPage(indexPlayListsInMyPageQueryService queryService.IndexPlayListsInMyPageQueryService, indexPlayListsInMyPageUsecase usecase.IIndexPlayListsInMyPage) *IndexPlayListsInMyPage <span class="cov8" title="1">{
        return &amp;IndexPlayListsInMyPage{
                IndexPlayListsInMyPageQueryService: indexPlayListsInMyPageQueryService,
                IndexPlayListsInMyPageUsecase:      indexPlayListsInMyPageUsecase,
        }
}</span>

func (indexPlayListsInMyPage IndexPlayListsInMyPage) IndexPlayListsInMyPage(c *gin.Context) <span class="cov8" title="1">{
        userIdInt := uint64(jwt.ExtractClaims(c)["id"].(float64))

        validationErrors := make(map[string]string)

        userId, userIdErr := model.NewUserID(userIdInt)
        if userIdErr != nil </span><span class="cov0" title="0">{
                validationErrors["user_id"] = userIdErr.Error()
        }</span>

        <span class="cov8" title="1">if len(validationErrors) != 0 </span><span class="cov0" title="0">{
                validationErrors, _ := json.Marshal(validationErrors)
                c.JSON(http.StatusBadRequest, gin.H{
                        "result":   "Validation Error.",
                        "messages": string(validationErrors),
                })
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">indexPlayListsInMyPageDTO := usecase.NewIndexPlayListsInMyPageDTO(userId)
        playLists := indexPlayListsInMyPage.IndexPlayListsInMyPageUsecase.All(indexPlayListsInMyPageDTO)

        jsonResult, jsonMarshalErr := json.Marshal(playLists)
        if jsonMarshalErr != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "result":   "Internal Server Error.",
                        "messages": jsonMarshalErr.Error(),
                })
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, string(jsonResult))</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package handler

import (
        "MyPIPE/domain/model"
        queryService_uploadMovies "MyPIPE/domain/queryService/UploadedMovies"
        "MyPIPE/domain/repository"
        "MyPIPE/usecase"
        "encoding/json"
        jwt "github.com/appleboy/gin-jwt/v2"
        "github.com/gin-gonic/gin"
        "net/http"
        "strconv"
        "fmt"
)

type Movie struct {
        UploadMovieQueryService   queryService_uploadMovies.UploadedMovies
        UploadMovieUsecase        usecase.IUploadedMovies
        MovieRepository           repository.MovieRepository
        UpdateMovieUsecase        usecase.IUpdateMovie
        ThumbnailUploadRepository repository.ThumbnailUploadRepository
        ChangeThumbnailUsecase    usecase.IChangeThumbnail
}

func NewMovie(uploadMovieQueryService queryService_uploadMovies.UploadedMovies, uploadMovieUsecase usecase.IUploadedMovies, movieRepository repository.MovieRepository, updateMovieUsecase usecase.IUpdateMovie, thumbnailUploadRepository repository.ThumbnailUploadRepository, changeThumbnailUsecase usecase.IChangeThumbnail) *Movie <span class="cov8" title="1">{
        return &amp;Movie{
                UploadMovieQueryService:   uploadMovieQueryService,
                UploadMovieUsecase:        uploadMovieUsecase,
                MovieRepository:           movieRepository,
                UpdateMovieUsecase:        updateMovieUsecase,
                ThumbnailUploadRepository: thumbnailUploadRepository,
                ChangeThumbnailUsecase:    changeThumbnailUsecase,
        }
}</span>

func (movie Movie) GetUploadedMovies(c *gin.Context) <span class="cov8" title="1">{
        userId := jwt.ExtractClaims(c)["id"]
        iuserId := uint64(userId.(float64))

        userIdModel, err := model.NewUserID(iuserId)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">result := movie.UploadMovieUsecase.Get(userIdModel)
        jsonResult, jsonMarshalErr := json.Marshal(result)
        if jsonMarshalErr != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "result":   "Internal Server Error.",
                        "messages": jsonMarshalErr.Error(),
                })
                c.Abort()
                return
        }</span> else<span class="cov8" title="1"> {
                c.JSON(http.StatusOK, string(jsonResult))
        }</span>
}

func (movie Movie) UpdateMovie(c *gin.Context) <span class="cov8" title="1">{
        userId := jwt.ExtractClaims(c)["id"]
        iuserId := uint64(userId.(float64))

        userIdModel, err := model.NewUserID(iuserId)

        var updateMovieDTO UpdateMovieDTO
        c.Bind(&amp;updateMovieDTO)

        validationErrors := make(map[string]string)

        if err != nil </span><span class="cov0" title="0">{
                validationErrors["user_id"] = err.Error()
        }</span>

        <span class="cov8" title="1">movieId, movieIdErr := model.NewMovieID(updateMovieDTO.MovieID)
        if movieIdErr != nil </span><span class="cov8" title="1">{
                validationErrors["movie_id"] = movieIdErr.Error()
        }</span>

        <span class="cov8" title="1">displayName, displayNameErr := model.NewMovieDisplayName(updateMovieDTO.DisplayName)
        if displayNameErr != nil </span><span class="cov0" title="0">{
                validationErrors["display_name"] = displayNameErr.Error()
        }</span>

        <span class="cov8" title="1">description, descriptionErr := model.NewMovieDescription(updateMovieDTO.Description)
        if descriptionErr != nil </span><span class="cov0" title="0">{
                validationErrors["description"] = descriptionErr.Error()
        }</span>

        <span class="cov8" title="1">public, publicErr := model.NewMoviePublic(updateMovieDTO.Public)
        if publicErr != nil </span><span class="cov8" title="1">{
                validationErrors["public"] = publicErr.Error()
        }</span>

        <span class="cov8" title="1">status, statusErr := model.NewMovieStatus(updateMovieDTO.Status)
        if statusErr != nil </span><span class="cov8" title="1">{
                validationErrors["status"] = statusErr.Error()
        }</span>

        <span class="cov8" title="1">if len(validationErrors) != 0 </span><span class="cov8" title="1">{
                validationErrors, _ := json.Marshal(validationErrors)
                c.JSON(http.StatusBadRequest, gin.H{
                        "result":   "Validation Error.",
                        "messages": string(validationErrors),
                })
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">updateDTO := usecase.UpdateDTO{
                UserID:      userIdModel,
                MovieID:     movieId,
                DisplayName: displayName,
                Description: description,
                Public:      public,
                Status:      status,
        }

        result, updateMovieUsecaseErr := movie.UpdateMovieUsecase.Update(&amp;updateDTO)
        if updateMovieUsecaseErr != nil </span><span class="cov8" title="1">{
                jsonUpdateMovieUsecaseErr, _ := json.Marshal(updateMovieUsecaseErr.Error())
                c.JSON(http.StatusInternalServerError, gin.H{
                        "result":   "Server Error.",
                        "messages": string(jsonUpdateMovieUsecaseErr),
                })
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">updatedData, _ := json.Marshal(result)
        c.JSON(http.StatusOK, gin.H{
                "result":      "Success.",
                "messages":    "OK",
                "updatedData": string(updatedData),
        })</span>
}

type UpdateMovieDTO struct {
        UserID      uint64
        MovieID     uint64 `json:"movie_id"`
        DisplayName string `json:"display_name"`
        Description string `json:"description"`
        Public      uint   `json:"public"`
        Status      uint   `json:"status"`
}

func (movie Movie) ChangeThumbnail(c *gin.Context) <span class="cov8" title="1">{

        //
        validationErrors := make(map[string]string)
        //ID
        iuserId := uint64(jwt.ExtractClaims(c)["id"].(float64))
        userId, userIdErr := model.NewUserID(iuserId)
        //ID valid
        if userIdErr != nil </span><span class="cov0" title="0">{
                validationErrors["user_id"] = userIdErr.Error()
        }</span>

        <span class="cov8" title="1">requestMovieId := c.PostForm("movie_id")
        imovieId, _ := strconv.ParseUint(requestMovieId, 10, 64)
        movieId, movieIdErr := model.NewMovieID(imovieId)
        if movieIdErr != nil </span><span class="cov8" title="1">{
                validationErrors["movie_id"] = movieIdErr.Error()
        }</span>

        <span class="cov8" title="1">thumbnailFile, thumbnailFileHeader, thumbnailFileErr := c.Request.FormFile("uploadThumbnail")
        var thumbnail *model.MovieThumbnail
        var thumbnailErr error
        if thumbnailFileErr != nil </span><span class="cov0" title="0">{
                validationErrors["thumbnail"] = thumbnailFileErr.Error()
        }</span>else<span class="cov8" title="1">{
                thumbnail,thumbnailErr = model.NewMovieThumbnail(thumbnailFile,*thumbnailFileHeader)
                if thumbnailErr != nil</span><span class="cov8" title="1">{
                        validationErrors["thumbnail"] = thumbnailErr.Error()
                }</span>
        }
        <span class="cov8" title="1">fmt.Println(validationErrors)
        if len(validationErrors) != 0 </span><span class="cov8" title="1">{
                validationErrors, _ := json.Marshal(validationErrors)
                c.JSON(http.StatusBadRequest, gin.H{
                        "result":   "Validation Error.",
                        "messages": string(validationErrors),
                })
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">changeThumbnailDTO := usecase.NewChangeThumbnailDTO(userId, movieId, *thumbnail)
        changeThumbnailUsecaseErr := movie.ChangeThumbnailUsecase.ChangeThumbnail(changeThumbnailDTO)
        if changeThumbnailUsecaseErr != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "result":   "Server Error.",
                        "messages": changeThumbnailUsecaseErr.Error(),
                })
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "result":   "OK",
                "messages": "OK",
        })</span>

}
</pre>
		
		<pre class="file" id="file16" style="display: none">package handler

import (
        "MyPIPE/domain/model"
        "MyPIPE/domain/repository"
        "MyPIPE/usecase"
        "encoding/json"
        jwt "github.com/appleboy/gin-jwt/v2"
        "github.com/gin-gonic/gin"
        "net/http"
)

type CreatePlayList struct {
        UserRepository        repository.UserRepository
        PlayListRepository    repository.PlayListRepository
        CreatePlayListUsecase usecase.ICreatePlayList
}

func NewCreatePlayList(
        userRepository repository.UserRepository,
        playListRepository repository.PlayListRepository,
        createPlayListUsecase usecase.ICreatePlayList,
) *CreatePlayList <span class="cov8" title="1">{
        return &amp;CreatePlayList{
                UserRepository:        userRepository,
                PlayListRepository:    playListRepository,
                CreatePlayListUsecase: createPlayListUsecase,
        }
}</span>

func (createPlayList CreatePlayList) CreatePlayList(c *gin.Context) <span class="cov8" title="1">{
        var playListJson CreatePlayListJson
        c.Bind(&amp;playListJson)

        userId := uint64(jwt.ExtractClaims(c)["id"].(float64))
        playListJson.UserID = userId

        validationErrors := make(map[string]string)
        var CreatePlayListDTO usecase.CreatePlayListDTO
        var userIDErr error
        CreatePlayListDTO.UserID, userIDErr = model.NewUserID(playListJson.UserID)
        if userIDErr != nil </span><span class="cov0" title="0">{
                validationErrors["user_id"] = userIDErr.Error()
        }</span>

        <span class="cov8" title="1">var playListNameErr error
        CreatePlayListDTO.PlayListName, playListNameErr = model.NewPlayListName(playListJson.PlayListName)
        if playListNameErr != nil </span><span class="cov8" title="1">{
                validationErrors["play_list_name"] = playListNameErr.Error()
        }</span>

        <span class="cov8" title="1">var playListDescriptionErr error
        CreatePlayListDTO.PlayListDescription, playListDescriptionErr = model.NewPlayListDescription(playListJson.PlayListDescription)
        if playListDescriptionErr != nil </span><span class="cov0" title="0">{
                validationErrors["play_list_description"] = playListDescriptionErr.Error()
        }</span>

        <span class="cov8" title="1">if len(validationErrors) != 0 </span><span class="cov8" title="1">{
                validationErrors, _ := json.Marshal(validationErrors)
                c.JSON(http.StatusBadRequest, gin.H{
                        "result":   "Validation Error.",
                        "messages": string(validationErrors),
                })
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">createPlayListUsecaseErr := createPlayList.CreatePlayListUsecase.CreatePlayList(&amp;CreatePlayListDTO)
        if createPlayListUsecaseErr != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "result":   "Error.",
                        "messages": createPlayListUsecaseErr.Error(),
                })
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "result":   "Success.",
                "messages": "OK",
        })</span>
}

type CreatePlayListJson struct {
        UserID              uint64
        PlayListName        string `json:"play_list_name"`
        PlayListDescription string `json:"play_list_description"`
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package handler

import (
        "MyPIPE/domain/factory"
        "MyPIPE/domain/model"
        "MyPIPE/domain/repository"
        "MyPIPE/usecase"
        "encoding/json"
        jwt "github.com/appleboy/gin-jwt/v2"
        "github.com/gin-gonic/gin"
        "net/http"
        "strconv"
)

type PlayList struct {
        PlayListRepository         repository.PlayListRepository
        PlayListMovieRepository    repository.PlayListMovieRepository
        PlayListMovieFactory       factory.IPlayListMovie
        AddPlayListItemUsecase     usecase.IAddPlayListItem
        DeletePlayListMovieUsecase usecase.IDeletePlayListMovie
}

func NewPlayListItem(
        playListRepository repository.PlayListRepository,
        playListMovieRepository repository.PlayListMovieRepository,
        playListMovieFactory factory.IPlayListMovie,
        addPlayListItemUsecase usecase.IAddPlayListItem,
        deletePlayListMovieUsecase usecase.IDeletePlayListMovie,
) *PlayList <span class="cov8" title="1">{
        return &amp;PlayList{
                PlayListRepository:         playListRepository,
                PlayListMovieRepository:    playListMovieRepository,
                PlayListMovieFactory:       playListMovieFactory,
                AddPlayListItemUsecase:     addPlayListItemUsecase,
                DeletePlayListMovieUsecase: deletePlayListMovieUsecase,
        }
}</span>

func (playList PlayList) AddPlayListMovie(c *gin.Context) <span class="cov8" title="1">{
        var playListItemAddJson AddPlayListItemJson
        c.Bind(&amp;playListItemAddJson)
        userId := uint64(jwt.ExtractClaims(c)["id"].(float64))
        playListItemAddJson.UserID = userId

        validationErrors := make(map[string]string)
        var playListItemAddDTO usecase.AddPlayListItemAddJson
        var playListIDErr error
        playListItemAddDTO.PlayListID, playListIDErr = model.NewPlayListID(playListItemAddJson.PlayListID)
        if playListIDErr != nil </span><span class="cov8" title="1">{
                validationErrors["play_list_id"] = playListIDErr.Error()
        }</span>

        <span class="cov8" title="1">var UserIDErr error
        playListItemAddDTO.UserID, UserIDErr = model.NewUserID(playListItemAddJson.UserID)
        if UserIDErr != nil </span><span class="cov0" title="0">{
                validationErrors["user_id"] = UserIDErr.Error()
        }</span>

        <span class="cov8" title="1">var MovieIDErr error
        playListItemAddDTO.MovieID, MovieIDErr = model.NewMovieID(playListItemAddJson.MovieID)
        if MovieIDErr != nil </span><span class="cov8" title="1">{
                validationErrors["movie_id"] = MovieIDErr.Error()
        }</span>

        <span class="cov8" title="1">if len(validationErrors) != 0 </span><span class="cov8" title="1">{
                validationErrors, _ := json.Marshal(validationErrors)
                c.JSON(http.StatusBadRequest, gin.H{
                        "result":   "Validation Error.",
                        "messages": string(validationErrors),
                })
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">err := playList.AddPlayListItemUsecase.AddPlayListItem(&amp;playListItemAddDTO)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "result":   "Error.",
                        "messages": err.Error(),
                })
                c.Abort()
                return
        }</span>
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "result":   "Success.",
                "messages": "OK",
        })</span>
}

type AddPlayListItemJson struct {
        PlayListID uint64 `json:"play_list_id"`
        UserID     uint64 `json:"user_id"`
        MovieID    uint64 `json:"movie_id"`
}

func (playList PlayList) DeletePlayListMovie(c *gin.Context) <span class="cov8" title="1">{

        validationErrors := make(map[string]string)
        playListIdFromQuery, _ := strconv.ParseUint(c.Query("play_list_id"), 10, 64)
        playListID, playListIDErr := model.NewPlayListID(playListIdFromQuery)
        if playListIDErr != nil </span><span class="cov8" title="1">{
                validationErrors["play_list_id"] = playListIDErr.Error()
        }</span>

        <span class="cov8" title="1">userId, UserIDErr := model.NewUserID(uint64(jwt.ExtractClaims(c)["id"].(float64)))
        if UserIDErr != nil </span><span class="cov0" title="0">{
                validationErrors["user_id"] = UserIDErr.Error()
        }</span>

        <span class="cov8" title="1">movieIdFromQuery, _ := strconv.ParseUint(c.Query("movie_id"), 10, 64)
        movieId, MovieIDErr := model.NewMovieID(movieIdFromQuery)
        if MovieIDErr != nil </span><span class="cov8" title="1">{
                validationErrors["movie_id"] = MovieIDErr.Error()
        }</span>

        <span class="cov8" title="1">if len(validationErrors) != 0 </span><span class="cov8" title="1">{
                validationErrors, _ := json.Marshal(validationErrors)
                c.JSON(http.StatusBadRequest, gin.H{
                        "result":   "Validation Error.",
                        "messages": string(validationErrors),
                })
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">playListMovieDeleteDTO := usecase.NewDeletePlayListMovieJson(playListID, userId, movieId)

        err := playList.DeletePlayListMovieUsecase.DeletePlayListItem(playListMovieDeleteDTO)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "result":   "Error.",
                        "messages": err.Error(),
                })
                c.Abort()
        }</span>
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "result":   "Success.",
                "messages": "OK",
        })</span>
}

type DeletePlayListItemJson struct {
        PlayListID uint64 `json:"play_list_id"`
        UserID     uint64 `json:"user_id"`
        MovieID    uint64 `json:"movie_id"`
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package handler

import (
        "MyPIPE/domain/model"
        "MyPIPE/domain/repository"
        "MyPIPE/usecase"
        jwt "github.com/appleboy/gin-jwt/v2"
        "github.com/gin-gonic/gin"
        "net/http"
)

type PostComment struct {
        CommentRepository  repository.CommentRepository
        MovieRepository    repository.MovieRepository
        PostCommentUsecase usecase.IPostComment
}

func NewPostComment(commentRepo repository.CommentRepository, movieRepo repository.MovieRepository, postCommentUsecase usecase.IPostComment) *PostComment <span class="cov8" title="1">{
        return &amp;PostComment{
                CommentRepository:  commentRepo,
                MovieRepository:    movieRepo,
                PostCommentUsecase: postCommentUsecase,
        }
}</span>

func (postComment PostComment) PostComment(c *gin.Context) <span class="cov8" title="1">{
        iuserId := uint64(jwt.ExtractClaims(c)["id"].(float64))

        var comment PostCommentJson
        c.Bind(&amp;comment)

        errorMessages := map[string]string{}
        validationErrorFlag := false

        body, bodyErr := model.NewCommentBody(comment.CommentBody)
        if bodyErr != nil </span><span class="cov8" title="1">{
                validationErrorFlag = true
                errorMessages["comment_body"] = bodyErr.Error()
        }</span>

        <span class="cov8" title="1">userId, userIdErr := model.NewUserID(iuserId)
        if userIdErr != nil </span><span class="cov0" title="0">{
                validationErrorFlag = true
                errorMessages["user_id"] = userIdErr.Error()
        }</span>

        <span class="cov8" title="1">movieId, movieIdErr := model.NewMovieID(comment.MovieID)
        if movieIdErr != nil </span><span class="cov8" title="1">{
                validationErrorFlag = true
                errorMessages["movie_id"] = movieIdErr.Error()
        }</span>

        <span class="cov8" title="1">if validationErrorFlag </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "result":   "Validation Error.",
                        "messages": errorMessages,
                })
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">postCommentDTO := usecase.NewPostCommentDTO(userId, movieId, body)

        postCommentErr := postComment.PostCommentUsecase.PostComment(postCommentDTO)
        if postCommentErr != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "result":   "Comment Post Failed.",
                        "messages": postCommentErr.Error(),
                })
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "message": "Posted!",
        })</span>
}

type PostCommentJson struct {
        CommentBody string `json:"comment_body"`
        MovieID     uint64 `json:"movie_id"`
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package handler

import (
        "MyPIPE/domain/model"
        "MyPIPE/domain/repository"
        "MyPIPE/usecase"
        "encoding/json"
        jwt "github.com/appleboy/gin-jwt/v2"
        "github.com/gin-gonic/gin"
        "net/http"
)

type UploadMovieFile struct {
        MovieRepository           repository.MovieRepository
        ThumbnailUploadRepository repository.ThumbnailUploadRepository
        MovieUploadRepository     repository.FileUpload
        PostMovieUsecase          usecase.IPostMovie
}

func NewUploadMovieFile(
        movieRepository repository.MovieRepository,
        thumbnailUploadRepository repository.ThumbnailUploadRepository,
        movieUploadRepository repository.FileUpload,
        postMovieUsecase usecase.IPostMovie,
) *UploadMovieFile <span class="cov0" title="0">{
        return &amp;UploadMovieFile{
                MovieRepository:           movieRepository,
                ThumbnailUploadRepository: thumbnailUploadRepository,
                MovieUploadRepository:     movieUploadRepository,
                PostMovieUsecase:          postMovieUsecase,
        }
}</span>

func (uploadMovieFile UploadMovieFile) UploadMovieFile(c *gin.Context) <span class="cov0" title="0">{

        //
        validationErrors := make(map[string]string)
        //ID
        iuserId := uint64(jwt.ExtractClaims(c)["id"].(float64))
        userId, userIdErr := model.NewUserID(iuserId)
        //ID valid
        if userIdErr != nil </span><span class="cov0" title="0">{
                validationErrors["user_id"] = userIdErr.Error()
        }</span>

        <span class="cov0" title="0">thumbnailFile, thumbnailFileHeader, thumbnailFileErr := c.Request.FormFile("uploadThumbnail")
        var thumbnail *model.MovieThumbnail
        var thumbnailErr error
        if thumbnailFileErr != nil </span><span class="cov0" title="0">{
                validationErrors["thumbnail"] = thumbnailFileErr.Error()
        }</span>else<span class="cov0" title="0">{
                thumbnail,thumbnailErr = model.NewMovieThumbnail(thumbnailFile,*thumbnailFileHeader)
                if thumbnailErr != nil</span><span class="cov0" title="0">{
                        validationErrors["thumbnail"] = thumbnailErr.Error()
                }</span>
        }

        //
        <span class="cov0" title="0">if len(validationErrors) != 0 </span><span class="cov0" title="0">{
                validationErrors, _ := json.Marshal(validationErrors)
                c.JSON(http.StatusBadRequest, gin.H{
                        "result":   "Validation Error.",
                        "messages": string(validationErrors),
                })
                c.Abort()
                return
        }</span>

        //&amp;
        <span class="cov0" title="0">file, header, fileErr := c.Request.FormFile("uploadMovie")
        if fileErr != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "result":   "MovieFileUpload Error.",
                        "messages": fileErr.Error(),
                })
                c.Abort()
                return
        }</span>

        //DTO
        <span class="cov0" title="0">postMovieDTO := usecase.NewPostMovieDTO(file, *header, *thumbnail, userId)

        newMovieModel, err := uploadMovieFile.PostMovieUsecase.PostMovie(postMovieDTO)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "result":   "PostMovie Error.",
                        "messages": err.Error(),
                })
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">jsonNewMovieModel, _ := json.Marshal(newMovieModel)
        c.JSON(http.StatusOK, string(jsonNewMovieModel))</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
